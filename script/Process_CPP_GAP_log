#! /usr/bin/python3
import os
import sys

nb_arg = len(sys.argv)
if not nb_arg in [4,5,6]:
    print("nb_arg should be equal to 4")
    print("Process_CPP_GAP_log   RES_gap   RES_cpp   BeginLine [nb_line]")
    sys.exit(0)

File1 = sys.argv[1]
File2 = sys.argv[2]
CritLine = sys.argv[3]
#
nb_linebef = 5
if nb_arg >= 5:
    nb_linebef = int(sys.argv[4])
print("nb_linebef=", nb_linebef)
#
nb_lineaft = 2
if nb_arg >= 6:
    nb_lineaft = int(sys.argv[5])
print("nb_lineaft=", nb_lineaft)

f1 = open(File1, "r")
pre_lines1 = f1.readlines()

f2 = open(File2, "r")
pre_lines2 = f2.readlines()

str1 = "XXX ELIMINATE begin\n"
str2 = "XXX ELIMINATE end\n"
def eliminate_marked_blocks(l_lines):
    l_lines_ret = []
    level_write = 0
    for e_line in l_lines:
        if e_line == str1:
            level_write += 1
        if level_write == 0:
            l_lines_ret.append(e_line)
        if e_line == str2:
            level_write += -1
    return l_lines_ret

def merge_lines(l_lines):
    l_lines_ret = []
    curr_line = ""
    for e_line in l_lines:
        if len(e_line) > 2 and e_line[-2] == '\\':
            curr_line += e_line[:-2]
        else:
            curr_line += e_line
            l_lines_ret.append(curr_line)
            curr_line = ""
    return l_lines_ret

def merge_lines_multiline(l_lines):
    l_lines_ret = []
    curr_line = ""
    level_bracket = 0;
    for e_line in l_lines:
        contrib_level_bracket = e_line.count('[') - e_line.count(']')
        level_bracket += contrib_level_bracket
        if len(e_line) > 2 and (e_line[-3:-1] == ', ' or level_bracket > 0):
            curr_line += e_line
        else:
            curr_line += e_line
            curr_line = curr_line.replace(", \n  ", ", ")
            curr_line = curr_line.replace(" \n ", " ")
            l_lines_ret.append(curr_line)
            curr_line = ""
    return l_lines_ret


def remove_debug_lines(l_lines):
    l_lines_ret = []
    for e_line in l_lines:
        if len(e_line) > 5:
            if e_line[:5] != "DEBUG":
                l_lines_ret.append(e_line)
    return l_lines_ret


def process_lines(l_linesA):
    l_linesB = eliminate_marked_blocks(l_linesA)
    l_linesC = merge_lines(l_linesB)
    l_linesD = merge_lines_multiline(l_linesC)
    l_linesE = remove_debug_lines(l_linesD)
    return l_linesE




lines1 = process_lines(pre_lines1)
lines2 = process_lines(pre_lines2)



def get_firstline(l_lines, eCrit):
    nb_line = len(l_lines)
    for iline in range(nb_line):
        e_line = l_lines[iline]
        LStr = e_line.split(eCrit)
        if len(LStr) > 1:
            return iline
    return -1

iline1 = get_firstline(lines1, CritLine)
iline2 = get_firstline(lines2, CritLine)
print("iline1=", iline1, " iline2=", iline2)
if iline1 == -1 or iline2 == -1:
    print("We found iline1=", iline1, " iline2=", iline2)
    sys.exit(0)



nbposs= min(len(lines1) - iline1, len(lines2) - iline2)

for iposs in range(nbposs):
    e_line1=lines1[iline1 + iposs]
    e_line2=lines2[iline2 + iposs]
#    import pdb
#    pdb.set_trace()
    if e_line1[3:] != e_line2[3:]:
        jline1 = iline1 + iposs
        jline2 = iline2 + iposs
        print("iposs=", iposs, " jline1=", jline1, " jline2=", jline2)
#        print("e_line1=", e_line1)
#        print("e_line2=", e_line2)
        print("LOOP")
        ibegin=-nb_linebef
        iend=nb_lineaft
        print("file1=", File1)
        for i in range(ibegin,iend):
            jposs = iposs + i
            if jposs >= 0 and jposs < nbposs:
                jline1 = iline1 + jposs
                f_line1=lines1[jline1]
                print("jline1=", jline1, " : ", f_line1[:-1])
        print("file2=", File2)
        for i in range(ibegin,iend):
            jposs = iposs + i
            if jposs >= 0 and jposs < nbposs:
                jline2 = iline2 + jposs
                f_line2=lines2[jline2]
                print("jline2=", jline2, " : ", f_line2[:-1])
        print("Normal termination of the program")
        sys.exit(1)


    
